


# MetaMarkup: Technical Notes

The MetaMarkup library provides a parser and renderer which is capable of transforming text in multiple markup languages into HTML in real time.  The text is rendered as you type, and syntax errors are noted in the rendered text as they occur.  The languages implemented in the present system are

- L1: a markup language with a syntax inspired by Lisp.

- Rational Markdown:  a variant  of Markdown which can render mathematical formulas, provide numbered section headings, a table of contents, etc.

-  MiniLaTeX, a subset of LaTeX with a few added features.

The task of managing multiple languages is made possible by a rules-based shift-reduce parser that transforms source code from any of the target languages to a common AST.  To change markup languages, one changes the rule set.  A single rendering function suffices to render the comon AST to HTML.


## Parsing and Rendering

The  parser consumes the source text as a list of strings, transforming it first into a list of blocks. Blocks are entities such as paragraphs, quotations, and LaTeX environments.
Once the blocks have been found, their contents are parsed to handle inline constructs such as TeX macros, marked text such as the below, and so on.

```
   *bold*, _italic_, `a[i] = a[i] + 1`, $a^2 + b^2 = c^2$,
   \section{Introduction}, \emph{important stuff]

The flow of data is

```
   List String -> List Block -> List TextBlock -> List (Html msg)

where the source text has type `List String` and the ulltimate AST, common to all languages handled, is of type `List TextBlock`.

### Block parser

The first step is carried out by a function

```
   Block.parse: Language -> Int -> List String -> List Block

where

```
   type Language
        = L1
        | Markdown
        | MiniLaTeX

The sole dependency on the `Language` argument is via the function

```
   classify : Language -> Bool -> String -> LineTypeData
ule
This function examines a string, principally to determine line type:

```
    type LineType
        = OrdinaryLine
        | VerbatimLine
        | BlankLine
        | BeginBlock String
        | EndBlock String
        | BeginVerbatimBlock String
        | EndVerbatimBlock String
        | Problem String

The language dependency is in fact concentrated in the function

```
   getLineTypeParser : Language -> String -> LineType

where, for instance, the function `getLine Markdown` has type `String -> LineType.` Functions of this type, one for each language, are what do the actual work.  Their implementation is quite small, about 50 lines of code.


### Text parser

The second step, parsing from `Blocks` to `TextBlocks` is carried  out by the function

```
    parse2 : Language -> List Block -> List TextBlock
    parse2 language blocks =
        List.map (Syntax.map (parseText language)) blocks

where

```
    parseText : Language -> String -> List Text
    parseText language input =
        case language of
            L1 ->
              Cursor.parseLoop L1.Rule.rules (Cursor.init input)
              |> .committed |> List.reverse

              ... and likewise for Markdown and MiniLaTeX

The dependency on `Language` is via the set of rules loaded in each case.  The files defining language rules wieigh in at about 100 lines of code.

### Language Dependencies

It takes two files and about 150 lines of code to define a markup language that can be handled by MetaMarkup.  We make no claim aobut the scope of the system.  It is adequate for L1, Rational Markdown, and MiniLaTeX, despite their obvous surface differences.  It would be interesting to characterize the kind of languages that can be handled by this system or close relaitves thereof.


### Rendering

The final step, rendering a list of `TextBlock` to a list of type `Html msg,` is carried out by a single language-independent function,

```
   render : Int -> Settings -> List TextBlock -> List (Element msg)

The AST, of type `List TextBlock,` is expressive enough to handle markup languages as different as L1, Markdown and MiniLaTeX.  For L1  we have

```
   [b important] => Marked "b" (Text Impotant)

while in Markdown the same construct reads

```
   *important* => Marked "*" (Text "important")

with MiniLaTeX as in this last example:

```
   \strong{important}  => Marked "strong" (Text "important")

The renderer has a dictionary that maps names of  `Marked` elements to rendering functions.  In the case at hand, the names `b,` `*` and `strong` are mapped to the same element.

One advantage of this architecture is that printing to PDF can be implemented by a function of type

```
   renderToLaTeX : List TextBlock -> String

that emits standard LaTeX source code.  Using this function as the final step in the pipeline considered above, we transform markup source text to LaTeX source text.  This can then be shipped to a server that accepts LaTeX files and returns them transformed into PDF.


